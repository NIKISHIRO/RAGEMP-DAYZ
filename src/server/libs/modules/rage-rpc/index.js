(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports = factory();
	else
		root["rpc"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://rpc/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! exports provided: register, unregister, call, callServer, callClient, callBrowsers, callBrowser, on, off, trigger, triggerClient, triggerServer, triggerBrowsers, triggerBrowser, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"register\", function() { return register; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unregister\", function() { return unregister; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"call\", function() { return call; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"callServer\", function() { return callServer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"callClient\", function() { return callClient; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"callBrowsers\", function() { return callBrowsers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"callBrowser\", function() { return callBrowser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"on\", function() { return on; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"off\", function() { return off; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trigger\", function() { return trigger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"triggerClient\", function() { return triggerClient; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"triggerServer\", function() { return triggerServer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"triggerBrowsers\", function() { return triggerBrowsers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"triggerBrowser\", function() { return triggerBrowser; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./src/util.ts\");\n\nconst environment = _util__WEBPACK_IMPORTED_MODULE_0__[\"getEnvironment\"]();\nif (!environment) throw 'Unknown RAGE environment';\nconst ERR_NOT_FOUND = 'PROCEDURE_NOT_FOUND';\nconst IDENTIFIER = '__rpc:id';\nconst PROCESS_EVENT = '__rpc:process';\nconst BROWSER_REGISTER = '__rpc:browserRegister';\nconst BROWSER_UNREGISTER = '__rpc:browserUnregister';\nconst TRIGGER_EVENT = '__rpc:triggerEvent';\nconst TRIGGER_EVENT_BROWSERS = '__rpc:triggerEventBrowsers';\nconst glob = environment === 'cef' ? window : global;\n\nif (!glob[PROCESS_EVENT]) {\n  glob.__rpcListeners = {};\n  glob.__rpcPending = {};\n  glob.__rpcEvListeners = {};\n\n  glob[PROCESS_EVENT] = (player, rawData) => {\n    if (environment !== \"server\") rawData = player;\n    const data = _util__WEBPACK_IMPORTED_MODULE_0__[\"parseData\"](rawData);\n\n    if (data.req) {\n      // someone is trying to remotely call a procedure\n      const info = {\n        id: data.id,\n        environment: data.fenv || data.env\n      };\n      if (environment === \"server\") info.player = player;\n      const part = {\n        ret: 1,\n        id: data.id,\n        env: environment\n      };\n      let ret;\n\n      switch (environment) {\n        case \"server\":\n          ret = ev => info.player.call(PROCESS_EVENT, [_util__WEBPACK_IMPORTED_MODULE_0__[\"stringifyData\"](ev)]);\n\n          break;\n\n        case \"client\":\n          {\n            if (data.env === \"server\") {\n              ret = ev => mp.events.callRemote(PROCESS_EVENT, _util__WEBPACK_IMPORTED_MODULE_0__[\"stringifyData\"](ev));\n            } else if (data.env === \"cef\") {\n              const browser = data.b && glob.__rpcBrowsers[data.b];\n              info.browser = browser;\n\n              ret = ev => browser && _util__WEBPACK_IMPORTED_MODULE_0__[\"isBrowserValid\"](browser) && passEventToBrowser(browser, ev, true);\n            }\n\n            break;\n          }\n\n        case \"cef\":\n          {\n            ret = ev => mp.trigger(PROCESS_EVENT, _util__WEBPACK_IMPORTED_MODULE_0__[\"stringifyData\"](ev));\n          }\n      }\n\n      if (ret) {\n        const promise = callProcedure(data.name, data.args, info);\n        if (!data.noRet) promise.then(res => ret({ ...part,\n          res\n        })).catch(err => ret({ ...part,\n          err: err ? err : null\n        }));\n      }\n    } else if (data.ret) {\n      // a previously called remote procedure has returned\n      const info = glob.__rpcPending[data.id];\n      if (environment === \"server\" && info.player !== player) return;\n\n      if (info) {\n        info.resolve(data.hasOwnProperty('err') ? _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseReject\"](data.err) : _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseResolve\"](data.res));\n        delete glob.__rpcPending[data.id];\n      }\n    }\n  };\n\n  if (environment !== \"cef\") {\n    mp.events.add(PROCESS_EVENT, glob[PROCESS_EVENT]);\n\n    if (environment === \"client\") {\n      // set up internal pass-through events\n      register('__rpc:callServer', ([name, args, noRet], info) => _callServer(name, args, {\n        fenv: info.environment,\n        noRet\n      }));\n      register('__rpc:callBrowsers', ([name, args, noRet], info) => _callBrowsers(null, name, args, {\n        fenv: info.environment,\n        noRet\n      })); // set up browser identifiers\n\n      glob.__rpcBrowsers = {};\n\n      const initBrowser = browser => {\n        const id = _util__WEBPACK_IMPORTED_MODULE_0__[\"uid\"]();\n        Object.keys(glob.__rpcBrowsers).forEach(key => {\n          const b = glob.__rpcBrowsers[key];\n          if (!b || !_util__WEBPACK_IMPORTED_MODULE_0__[\"isBrowserValid\"](b) || b === browser) delete glob.__rpcBrowsers[key];\n        });\n        glob.__rpcBrowsers[id] = browser;\n        browser.execute(`\n                    window.name = '${id}';\n                    if(typeof window['${IDENTIFIER}'] === 'undefined'){\n                        window['${IDENTIFIER}'] = Promise.resolve(window.name);\n                    }else{\n                        window['${IDENTIFIER}:resolve'](window.name);\n                    }\n                `);\n      };\n\n      mp.browsers.forEach(initBrowser);\n      mp.events.add('browserCreated', initBrowser); // set up browser registration map\n\n      glob.__rpcBrowserProcedures = {};\n      mp.events.add(BROWSER_REGISTER, data => {\n        const [browserId, name] = JSON.parse(data);\n        glob.__rpcBrowserProcedures[name] = browserId;\n      });\n      mp.events.add(BROWSER_UNREGISTER, data => {\n        const [browserId, name] = JSON.parse(data);\n        if (glob.__rpcBrowserProcedures[name] === browserId) delete glob.__rpcBrowserProcedures[name];\n      });\n      register(TRIGGER_EVENT_BROWSERS, ([name, args], info) => {\n        Object.values(glob.__rpcBrowsers).forEach(browser => {\n          _callBrowser(browser, TRIGGER_EVENT, [name, args], {\n            fenv: info.environment,\n            noRet: 1\n          });\n        });\n      });\n    }\n  } else {\n    if (typeof glob[IDENTIFIER] === 'undefined') {\n      glob[IDENTIFIER] = new Promise(resolve => {\n        if (window.name) {\n          resolve(window.name);\n        } else {\n          glob[IDENTIFIER + ':resolve'] = resolve;\n        }\n      });\n    }\n  }\n\n  register(TRIGGER_EVENT, ([name, args], info) => callEvent(name, args, info));\n}\n\nfunction passEventToBrowser(browser, data, ignoreNotFound) {\n  const raw = _util__WEBPACK_IMPORTED_MODULE_0__[\"stringifyData\"](data);\n  browser.execute(`var process = window[\"${PROCESS_EVENT}\"]; if(process){ process(${JSON.stringify(raw)}); }else{ ${ignoreNotFound ? '' : `mp.trigger(\"${PROCESS_EVENT}\", '{\"ret\":1,\"id\":\"${data.id}\",\"err\":\"${ERR_NOT_FOUND}\",\"env\":\"cef\"}');`} }`);\n}\n\nfunction callProcedure(name, args, info) {\n  const listener = glob.__rpcListeners[name];\n  if (!listener) return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseReject\"](ERR_NOT_FOUND);\n  return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseResolve\"](listener(args, info));\n}\n/**\n * Register a procedure.\n * @param {string} name - The name of the procedure.\n * @param {function} cb - The procedure's callback. The return value will be sent back to the caller.\n * @returns {Function} The function, which unregister the event.\n */\n\n\nfunction register(name, cb) {\n  if (arguments.length !== 2) throw 'register expects 2 arguments: \"name\" and \"cb\"';\n  if (environment === \"cef\") glob[IDENTIFIER].then(id => mp.trigger(BROWSER_REGISTER, JSON.stringify([id, name])));\n  glob.__rpcListeners[name] = cb;\n  return () => unregister(name);\n}\n/**\n * Unregister a procedure.\n * @param {string} name - The name of the procedure.\n */\n\nfunction unregister(name) {\n  if (arguments.length !== 1) throw 'unregister expects 1 argument: \"name\"';\n  if (environment === \"cef\") glob[IDENTIFIER].then(id => mp.trigger(BROWSER_UNREGISTER, JSON.stringify([id, name])));\n  glob.__rpcListeners[name] = undefined;\n}\n/**\n * Calls a local procedure. Only procedures registered in the same context will be resolved.\n *\n * Can be called from any environment.\n *\n * @param name - The name of the locally registered procedure.\n * @param args - Any parameters for the procedure.\n * @param options - Any options.\n * @returns The result from the procedure.\n */\n\nfunction call(name, args, options = {}) {\n  if (arguments.length < 1 || arguments.length > 3) return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseReject\"]('call expects 1 to 3 arguments: \"name\", optional \"args\", and optional \"options\"');\n  return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseTimeout\"](callProcedure(name, args, {\n    environment\n  }), options.timeout);\n}\n\nfunction _callServer(name, args, extraData = {}) {\n  switch (environment) {\n    case \"server\":\n      {\n        return call(name, args);\n      }\n\n    case \"client\":\n      {\n        const id = _util__WEBPACK_IMPORTED_MODULE_0__[\"uid\"]();\n        return new Promise(resolve => {\n          if (!extraData.noRet) {\n            glob.__rpcPending[id] = {\n              resolve\n            };\n          }\n\n          const event = {\n            req: 1,\n            id,\n            name,\n            env: environment,\n            args,\n            ...extraData\n          };\n          mp.events.callRemote(PROCESS_EVENT, _util__WEBPACK_IMPORTED_MODULE_0__[\"stringifyData\"](event));\n        });\n      }\n\n    case \"cef\":\n      {\n        return callClient('__rpc:callServer', [name, args, +extraData.noRet]);\n      }\n  }\n}\n/**\n * Calls a remote procedure registered on the server.\n *\n * Can be called from any environment.\n *\n * @param name - The name of the registered procedure.\n * @param args - Any parameters for the procedure.\n * @param options - Any options.\n * @returns The result from the procedure.\n */\n\n\nfunction callServer(name, args, options = {}) {\n  if (arguments.length < 1 || arguments.length > 3) return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseReject\"]('callServer expects 1 to 3 arguments: \"name\", optional \"args\", and optional \"options\"');\n  let extraData = {};\n  if (options.noRet) extraData.noRet = 1;\n  return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseTimeout\"](_callServer(name, args, extraData), options.timeout);\n}\n\nfunction _callClient(player, name, args, extraData = {}) {\n  switch (environment) {\n    case 'client':\n      {\n        return call(name, args);\n      }\n\n    case 'server':\n      {\n        const id = _util__WEBPACK_IMPORTED_MODULE_0__[\"uid\"]();\n        return new Promise(resolve => {\n          if (!extraData.noRet) {\n            glob.__rpcPending[id] = {\n              resolve,\n              player\n            };\n          }\n\n          const event = {\n            req: 1,\n            id,\n            name,\n            env: environment,\n            args,\n            ...extraData\n          };\n          player.call(PROCESS_EVENT, [_util__WEBPACK_IMPORTED_MODULE_0__[\"stringifyData\"](event)]);\n        });\n      }\n\n    case 'cef':\n      {\n        const id = _util__WEBPACK_IMPORTED_MODULE_0__[\"uid\"]();\n        return glob[IDENTIFIER].then(browserId => {\n          return new Promise(resolve => {\n            if (!extraData.noRet) {\n              glob.__rpcPending[id] = {\n                resolve\n              };\n            }\n\n            const event = {\n              b: browserId,\n              req: 1,\n              id,\n              name,\n              env: environment,\n              args,\n              ...extraData\n            };\n            mp.trigger(PROCESS_EVENT, _util__WEBPACK_IMPORTED_MODULE_0__[\"stringifyData\"](event));\n          });\n        });\n      }\n  }\n}\n/**\n * Calls a remote procedure registered on the client.\n *\n * Can be called from any environment.\n *\n * @param player - The player to call the procedure on.\n * @param name - The name of the registered procedure.\n * @param args - Any parameters for the procedure.\n * @param options - Any options.\n * @returns The result from the procedure.\n */\n\n\nfunction callClient(player, name, args, options = {}) {\n  switch (environment) {\n    case 'client':\n      {\n        options = args || {};\n        args = name;\n        name = player;\n        player = null;\n        if (arguments.length < 1 || arguments.length > 3 || typeof name !== 'string') return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseReject\"]('callClient from the client expects 1 to 3 arguments: \"name\", optional \"args\", and optional \"options\"');\n        break;\n      }\n\n    case 'server':\n      {\n        if (arguments.length < 2 || arguments.length > 4 || typeof player !== 'object') return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseReject\"]('callClient from the server expects 2 to 4 arguments: \"player\", \"name\", optional \"args\", and optional \"options\"');\n        break;\n      }\n\n    case 'cef':\n      {\n        options = args || {};\n        args = name;\n        name = player;\n        player = null;\n        if (arguments.length < 1 || arguments.length > 3 || typeof name !== 'string') return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseReject\"]('callClient from the browser expects 1 to 3 arguments: \"name\", optional \"args\", and optional \"options\"');\n        break;\n      }\n  }\n\n  let extraData = {};\n  if (options.noRet) extraData.noRet = 1;\n  return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseTimeout\"](_callClient(player, name, args, extraData), options.timeout);\n}\n\nfunction _callBrowser(browser, name, args, extraData = {}) {\n  return new Promise(resolve => {\n    const id = _util__WEBPACK_IMPORTED_MODULE_0__[\"uid\"]();\n\n    if (!extraData.noRet) {\n      glob.__rpcPending[id] = {\n        resolve\n      };\n    }\n\n    passEventToBrowser(browser, {\n      req: 1,\n      id,\n      name,\n      env: environment,\n      args,\n      ...extraData\n    }, false);\n  });\n}\n\nfunction _callBrowsers(player, name, args, extraData = {}) {\n  switch (environment) {\n    case 'client':\n      const browserId = glob.__rpcBrowserProcedures[name];\n      if (!browserId) return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseReject\"](ERR_NOT_FOUND);\n      const browser = glob.__rpcBrowsers[browserId];\n      if (!browser || !_util__WEBPACK_IMPORTED_MODULE_0__[\"isBrowserValid\"](browser)) return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseReject\"](ERR_NOT_FOUND);\n      return _callBrowser(browser, name, args, extraData);\n\n    case 'server':\n      return _callClient(player, '__rpc:callBrowsers', [name, args, +extraData.noRet], extraData);\n\n    case 'cef':\n      return _callClient(null, '__rpc:callBrowsers', [name, args, +extraData.noRet], extraData);\n  }\n}\n/**\n * Calls a remote procedure registered in any browser context.\n *\n * Can be called from any environment.\n *\n * @param player - The player to call the procedure on.\n * @param name - The name of the registered procedure.\n * @param args - Any parameters for the procedure.\n * @param options - Any options.\n * @returns The result from the procedure.\n */\n\n\nfunction callBrowsers(player, name, args, options = {}) {\n  let promise;\n  let extraData = {};\n\n  switch (environment) {\n    case 'client':\n    case 'cef':\n      options = args || {};\n      args = name;\n      name = player;\n      if (arguments.length < 1 || arguments.length > 3) return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseReject\"]('callBrowsers from the client or browser expects 1 to 3 arguments: \"name\", optional \"args\", and optional \"options\"');\n      if (options.noRet) extraData.noRet = 1;\n      promise = _callBrowsers(null, name, args, extraData);\n      break;\n\n    case 'server':\n      if (arguments.length < 2 || arguments.length > 4) return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseReject\"]('callBrowsers from the server expects 2 to 4 arguments: \"player\", \"name\", optional \"args\", and optional \"options\"');\n      if (options.noRet) extraData.noRet = 1;\n      promise = _callBrowsers(player, name, args, extraData);\n      break;\n  }\n\n  if (promise) {\n    return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseTimeout\"](promise, options.timeout);\n  }\n}\n/**\n * Calls a remote procedure registered in a specific browser instance.\n *\n * Client-side environment only.\n *\n * @param browser - The browser instance.\n * @param name - The name of the registered procedure.\n * @param args - Any parameters for the procedure.\n * @param options - Any options.\n * @returns The result from the procedure.\n */\n\nfunction callBrowser(browser, name, args, options = {}) {\n  if (environment !== 'client') return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseReject\"]('callBrowser can only be used in the client environment');\n  if (arguments.length < 2 || arguments.length > 4) return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseReject\"]('callBrowser expects 2 to 4 arguments: \"browser\", \"name\", optional \"args\", and optional \"options\"');\n  let extraData = {};\n  if (options.noRet) extraData.noRet = 1;\n  return _util__WEBPACK_IMPORTED_MODULE_0__[\"promiseTimeout\"](_callBrowser(browser, name, args, extraData), options.timeout);\n}\n\nfunction callEvent(name, args, info) {\n  const listeners = glob.__rpcEvListeners[name];\n\n  if (listeners) {\n    listeners.forEach(listener => listener(args, info));\n  }\n}\n/**\n * Register an event handler.\n * @param {string} name - The name of the event.\n * @param cb - The callback for the event.\n * @returns {Function} The function, which off the event.\n */\n\n\nfunction on(name, cb) {\n  if (arguments.length !== 2) throw 'on expects 2 arguments: \"name\" and \"cb\"';\n  const listeners = glob.__rpcEvListeners[name] || new Set();\n  listeners.add(cb);\n  glob.__rpcEvListeners[name] = listeners;\n  return () => off(name, cb);\n}\n/**\n * Unregister an event handler.\n * @param {string} name - The name of the event.\n * @param cb - The callback for the event.\n */\n\nfunction off(name, cb) {\n  if (arguments.length !== 2) throw 'off expects 2 arguments: \"name\" and \"cb\"';\n  const listeners = glob.__rpcEvListeners[name];\n\n  if (listeners) {\n    listeners.delete(cb);\n  }\n}\n/**\n * Triggers a local event. Only events registered in the same context will be triggered.\n *\n * Can be called from any environment.\n *\n * @param name - The name of the locally registered event.\n * @param args - Any parameters for the event.\n */\n\nfunction trigger(name, args) {\n  if (arguments.length < 1 || arguments.length > 2) throw 'trigger expects 1 or 2 arguments: \"name\", and optional \"args\"';\n  callEvent(name, args, {\n    environment\n  });\n}\n/**\n * Triggers an event registered on the client.\n *\n * Can be called from any environment.\n *\n * @param player - The player to call the procedure on.\n * @param name - The name of the event.\n * @param args - Any parameters for the event.\n */\n\nfunction triggerClient(player, name, args) {\n  switch (environment) {\n    case 'client':\n      {\n        args = name;\n        name = player;\n        player = null;\n        if (arguments.length < 1 || arguments.length > 2 || typeof name !== 'string') throw 'triggerClient from the client expects 1 or 2 arguments: \"name\", and optional \"args\"';\n        break;\n      }\n\n    case 'server':\n      {\n        if (arguments.length < 2 || arguments.length > 3 || typeof player !== 'object') throw 'triggerClient from the server expects 2 or 3 arguments: \"player\", \"name\", and optional \"args\"';\n        break;\n      }\n\n    case 'cef':\n      {\n        args = name;\n        name = player;\n        player = null;\n        if (arguments.length < 1 || arguments.length > 2 || typeof name !== 'string') throw 'triggerClient from the browser expects 1 or 2 arguments: \"name\", and optional \"args\"';\n        break;\n      }\n  }\n\n  _callClient(player, TRIGGER_EVENT, [name, args], {\n    noRet: 1\n  });\n}\n/**\n * Triggers an event registered on the server.\n *\n * Can be called from any environment.\n *\n * @param name - The name of the event.\n * @param args - Any parameters for the event.\n */\n\nfunction triggerServer(name, args) {\n  if (arguments.length < 1 || arguments.length > 2) throw 'triggerServer expects 1 or 2 arguments: \"name\", and optional \"args\"';\n\n  _callServer(TRIGGER_EVENT, [name, args], {\n    noRet: 1\n  });\n}\n/**\n * Triggers an event registered in any browser context.\n *\n * Can be called from any environment.\n *\n * @param player - The player to call the procedure on.\n * @param name - The name of the event.\n * @param args - Any parameters for the event.\n */\n\nfunction triggerBrowsers(player, name, args) {\n  switch (environment) {\n    case 'client':\n    case 'cef':\n      args = name;\n      name = player;\n      player = null;\n      if (arguments.length < 1 || arguments.length > 2) throw 'triggerBrowsers from the client or browser expects 1 or 2 arguments: \"name\", and optional \"args\"';\n      break;\n\n    case 'server':\n      if (arguments.length < 2 || arguments.length > 3) throw 'triggerBrowsers from the server expects 2 or 3 arguments: \"player\", \"name\", and optional \"args\"';\n      break;\n  }\n\n  _callClient(player, TRIGGER_EVENT_BROWSERS, [name, args], {\n    noRet: 1\n  });\n}\n/**\n * Triggers an event registered in a specific browser instance.\n *\n * Client-side environment only.\n *\n * @param browser - The browser instance.\n * @param name - The name of the event.\n * @param args - Any parameters for the event.\n */\n\nfunction triggerBrowser(browser, name, args) {\n  if (environment !== 'client') throw 'callBrowser can only be used in the client environment';\n  if (arguments.length < 2 || arguments.length > 4) throw 'callBrowser expects 2 or 3 arguments: \"browser\", \"name\", and optional \"args\"';\n\n  _callBrowser(browser, TRIGGER_EVENT, [name, args], {\n    noRet: 1\n  });\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  register,\n  unregister,\n  call,\n  callServer,\n  callClient,\n  callBrowsers,\n  callBrowser,\n  on,\n  off,\n  trigger,\n  triggerServer,\n  triggerClient,\n  triggerBrowsers,\n  triggerBrowser\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://rpc/./src/index.ts?");

/***/ }),

/***/ "./src/util.ts":
/*!*********************!*\
  !*** ./src/util.ts ***!
  \*********************/
/*! exports provided: uid, getEnvironment, stringifyData, parseData, promiseResolve, promiseReject, promiseTimeout, isBrowserValid */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"uid\", function() { return uid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getEnvironment\", function() { return getEnvironment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringifyData\", function() { return stringifyData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseData\", function() { return parseData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"promiseResolve\", function() { return promiseResolve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"promiseReject\", function() { return promiseReject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"promiseTimeout\", function() { return promiseTimeout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBrowserValid\", function() { return isBrowserValid; });\nvar MpTypes;\n\n(function (MpTypes) {\n  MpTypes[\"Blip\"] = \"b\";\n  MpTypes[\"Checkpoint\"] = \"cp\";\n  MpTypes[\"Colshape\"] = \"c\";\n  MpTypes[\"Label\"] = \"l\";\n  MpTypes[\"Marker\"] = \"m\";\n  MpTypes[\"Object\"] = \"o\";\n  MpTypes[\"Pickup\"] = \"p\";\n  MpTypes[\"Player\"] = \"pl\";\n  MpTypes[\"Vehicle\"] = \"v\";\n})(MpTypes || (MpTypes = {}));\n\nfunction isObjectMpType(obj, type) {\n  const client = getEnvironment() === 'client';\n\n  if (obj && typeof obj === 'object' && typeof obj.id !== 'undefined') {\n    const test = (type, collection, mpType) => client ? obj.type === type && collection.at(obj.id) === obj : obj instanceof mpType;\n\n    switch (type) {\n      case MpTypes.Blip:\n        return test('blip', mp.blips, mp.Blip);\n\n      case MpTypes.Checkpoint:\n        return test('checkpoint', mp.checkpoints, mp.Checkpoint);\n\n      case MpTypes.Colshape:\n        return test('colshape', mp.colshapes, mp.Colshape);\n\n      case MpTypes.Label:\n        return test('textlabel', mp.labels, mp.TextLabel);\n\n      case MpTypes.Marker:\n        return test('marker', mp.markers, mp.Marker);\n\n      case MpTypes.Object:\n        return test('object', mp.objects, mp.Object);\n\n      case MpTypes.Pickup:\n        return test('pickup', mp.pickups, mp.Pickup);\n\n      case MpTypes.Player:\n        return test('player', mp.players, mp.Player);\n\n      case MpTypes.Vehicle:\n        return test('vehicle', mp.vehicles, mp.Vehicle);\n    }\n  }\n\n  return false;\n}\n\nfunction uid() {\n  const first = Math.random() * 46656 | 0;\n  const second = Math.random() * 46656 | 0;\n  const firstPart = ('000' + first.toString(36)).slice(-3);\n  const secondPart = ('000' + second.toString(36)).slice(-3);\n  return firstPart + secondPart;\n}\nfunction getEnvironment() {\n  if (mp.joaat) return 'server';else if (mp.game && mp.game.joaat) return 'client';else if (mp.trigger) return 'cef';\n}\nfunction stringifyData(data) {\n  const env = getEnvironment();\n  return JSON.stringify(data, (_, value) => {\n    if (env === 'client' || env === 'server' && value && typeof value === 'object') {\n      let type;\n      if (isObjectMpType(value, MpTypes.Blip)) type = MpTypes.Blip;else if (isObjectMpType(value, MpTypes.Checkpoint)) type = MpTypes.Checkpoint;else if (isObjectMpType(value, MpTypes.Colshape)) type = MpTypes.Colshape;else if (isObjectMpType(value, MpTypes.Marker)) type = MpTypes.Marker;else if (isObjectMpType(value, MpTypes.Object)) type = MpTypes.Object;else if (isObjectMpType(value, MpTypes.Pickup)) type = MpTypes.Pickup;else if (isObjectMpType(value, MpTypes.Player)) type = MpTypes.Player;else if (isObjectMpType(value, MpTypes.Vehicle)) type = MpTypes.Vehicle;\n      if (type) return {\n        __t: type,\n        i: typeof value.remoteId === 'number' ? value.remoteId : value.id\n      };\n    }\n\n    return value;\n  });\n}\nfunction parseData(data) {\n  const env = getEnvironment();\n  return JSON.parse(data, (_, value) => {\n    if ((env === 'client' || env === 'server') && value && typeof value === 'object' && typeof value['__t'] === 'string' && typeof value.i === 'number' && Object.keys(value).length === 2) {\n      const id = value.i;\n      const type = value['__t'];\n      let collection;\n\n      switch (type) {\n        case MpTypes.Blip:\n          collection = mp.blips;\n          break;\n\n        case MpTypes.Checkpoint:\n          collection = mp.checkpoints;\n          break;\n\n        case MpTypes.Colshape:\n          collection = mp.colshapes;\n          break;\n\n        case MpTypes.Label:\n          collection = mp.labels;\n          break;\n\n        case MpTypes.Marker:\n          collection = mp.markers;\n          break;\n\n        case MpTypes.Object:\n          collection = mp.objects;\n          break;\n\n        case MpTypes.Pickup:\n          collection = mp.pickups;\n          break;\n\n        case MpTypes.Player:\n          collection = mp.players;\n          break;\n\n        case MpTypes.Vehicle:\n          collection = mp.vehicles;\n          break;\n      }\n\n      if (collection) return collection[env === 'client' ? 'atRemoteId' : 'at'](id);\n    }\n\n    return value;\n  });\n}\nfunction promiseResolve(result) {\n  return new Promise(resolve => setTimeout(() => resolve(result), 0));\n}\nfunction promiseReject(error) {\n  return new Promise((_, reject) => setTimeout(() => reject(error), 0));\n}\nfunction promiseTimeout(promise, timeout) {\n  if (typeof timeout === 'number') {\n    return Promise.race([new Promise((_, reject) => {\n      setTimeout(() => reject('TIMEOUT'), timeout);\n    }), promise]);\n  } else return promise;\n}\nfunction isBrowserValid(browser) {\n  try {\n    browser.url;\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\n\n//# sourceURL=webpack://rpc/./src/util.ts?");

/***/ })

/******/ });
});